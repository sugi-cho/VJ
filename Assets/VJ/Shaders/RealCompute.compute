// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel build
#pragma kernel breakGrid
#pragma kernel breakAll

#include "RealSense.hlsl"
float time, dt;

[numthreads(8,1,1)]
void build (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    voxelParticle p = _ParticleBuffer[idx];
    uint idx0 = _IndicesBuffer[idx*3+0];
    uint idx1 = _IndicesBuffer[idx*3+1];
    uint idx2 = _IndicesBuffer[idx*3+2];

    float3 v0 = _VertBuffer[idx0];
    float3 v1 = _VertBuffer[idx1];
    float3 v2 = _VertBuffer[idx2];

    v0.y *= -1;
    v1.y *= -1;
    v2.y *= -1;

    float t = frac(time*.25 - rand(float2( idx0 * 0.0000032552, idx1 * 0.0000032552)) * 100) * 2.0 - 1.0;
    float size = abs(v0 - v1) + abs(v1 - v2) + abs(v2 - v0);
    float3 normal = normalize(cross(v0-v1, v2-v0));
    float3 center = (v0+v1+v2)/3.0;

    half diff = length(center) - length(p.pos);

    if(0.1 < edgeLength(v0,v1,v2))
        size = 0;

    if(t < 0 && p.prop < 1.0){
        p.vel = normal;
        p.pos = center;
        p.normal = normal;
        p.size = lerp(size,p.size,exp(-dt*10));
        p.prop = 0;
    }
    else if((p.prop < 1.0 || 2.5 < p.prop) && 1.0 < diff && length(p.pos) < 5.0){
        p.prop = 1.0;
    }

    if(1.0 <= p.prop && p.prop < 2.5){
        float t = saturate(p.prop-1.0);
        float3 n = dfNoise(p.pos) * t;
        p.vel += float3(0,1,0) * dt;
        p.pos += (p.vel+n) * dt;
        p.vel *= exp(-dt*10);
        p.normal = normalize(p.vel);
        p.prop += dt;
        if(2.5 < p.prop){
            p.vel = normal;
            p.pos = center;
            p.normal = normal;
            p.size = size;
            p.prop = 3;
        }
    }
    else if(2.5 < p.prop && 0.0 < t)
        p.prop = 0;
    p.t = t;

    _ParticleBuffer[idx] = p;
}

[numthreads(8,1,1)]
void breakAll (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    voxelParticle p = _ParticleBuffer[idx];
    p.prop = 1.0;
    _ParticleBuffer[idx] = p;
}

[numthreads(8,1,1)]
void breakGrid (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    voxelParticle p = _ParticleBuffer[idx];
    float2 seed = float2(floor(p.pos.x*12.0 + floor(5 * p.pos.z) ) * 0.543, floor(p.pos.y*15.0 ) * 0.4321) + frac(time);
    float r = rand(seed);
    if(r < 0.1 && p.t < 1.0){
        p.prop = 1.0;
    }
    _ParticleBuffer[idx] = p;
}